<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>StdIn.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCoverage analysis of project &quot;JWebSwing&quot; (powered by JaCoCo from EclEmma)</a> &gt; <a href="index.source.html" class="el_package">za.co.mmagon.jwebswing.utilities.dualquickpivot</a> &gt; <span class="el_source">StdIn.java</span></div><h1>StdIn.java</h1><pre class="source lang-java linenums">/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package za.co.mmagon.jwebswing.utilities.dualquickpivot;

/**
 * ****************************************************************************
 * Compilation: javac StdIn.java
 * Execution: java StdIn (interactive test of basic functionality)
 * Dependencies: none
 * &lt;p&gt;
 * Reads in data of various types from standard input.
 * &lt;p&gt;
 *****************************************************************************
 */
import java.util.ArrayList;
import java.util.InputMismatchException;
import java.util.Locale;
import java.util.NoSuchElementException;
import java.util.Scanner;
import java.util.regex.Pattern;
import org.apache.log4j.Logger;
import za.co.mmagon.LoggerFactory;

/**
 * The &amp;lt;tt&amp;gt;StdIn&amp;lt;/tt&amp;gt; class provides static methods for reading strings
 * and numbers from standard input.
 * These functions fall into one of four categories:
 * &lt;p&gt;
 * &amp;lt;ul&amp;gt;
 * &amp;lt;li&amp;gt;those for reading individual tokens from standard input, one at a time,
 * and converting each to a number, string, or boolean
 * &amp;lt;li&amp;gt;those for reading characters from standard input, one at a time
 * &amp;lt;li&amp;gt;those for reading lines from standard input, one at a time
 * &amp;lt;li&amp;gt;those for reading a sequence of values of the same type from standard input,
 * and returning the values in an array
 * &amp;lt;/ul&amp;gt;
 * &lt;p&gt;
 * Generally, it is best not to mix functions from the different
 * categories in the same program.
 * &lt;p&gt;
 * &amp;lt;b&amp;gt;Reading tokens from standard input one at a time,
 * and converting to numbers and strings.&amp;lt;/b&amp;gt;
 * You can use the following methods to read numbers, strings, and booleans
 * from standard input:
 * &amp;lt;ul&amp;gt;
 * &amp;lt;li&amp;gt; {@link #readInt()}
 * &amp;lt;li&amp;gt; {@link #readDouble()}
 * &amp;lt;li&amp;gt; {@link #readString()}
 * &amp;lt;li&amp;gt; {@link #readBoolean()}
 * &amp;lt;li&amp;gt; {@link #readShort()}
 * &amp;lt;li&amp;gt; {@link #readLong()}
 * &amp;lt;li&amp;gt; {@link #readFloat()}
 * &amp;lt;li&amp;gt; {@link #readByte()}
 * &amp;lt;/ul&amp;gt;
 * &lt;p&gt;
 * Each method skips over any input that is whitespace. Then, it reads
 * the next token and attempts to convert it into a value of the specified
 * type. If it succeeds, it returns that value; otherwise, it
 * throws a {@link InputMismatchException}.
 * &lt;p&gt;
 * &amp;lt;em&amp;gt;Whitespace&amp;lt;/em&amp;gt; includes spaces, tabs, and newlines; the full definition
 * is inherited from {@link Character#isWhitespace(char)}.
 * A &amp;lt;em&amp;gt;token&amp;lt;/em&amp;gt; is a maximal sequence of non-whitespace characters.
 * The precise rules for describing which tokens can be converted to
 * integers and floating-point numbers are inherited from
 * &amp;lt;a href = &quot;http://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html#number-syntax&quot;&amp;gt;Scanner&amp;lt;/a&amp;gt;,
 * using the locale {@link Locale#US}; the rules
 * for floating-point numbers are slightly different
 * from those in {@link Double#valueOf(String)},
 * but unlikely to be of concern to most programmers.
 * &lt;p&gt;
 * &amp;lt;b&amp;gt;Reading characters from standard input, one at a time.&amp;lt;/b&amp;gt;
 * You can use the following two methods to read characters from standard input:
 * &amp;lt;ul&amp;gt;
 * &amp;lt;li&amp;gt; {@link #hasNextChar()}
 * &amp;lt;li&amp;gt; {@link #readChar()}
 * &amp;lt;/ul&amp;gt;
 * &lt;p&gt;
 * The first method returns true if standard input has more input (including whitespace).
 * The second method reads and returns the next character of input on standard
 * input (possibly a whitespace character).
 * &lt;p&gt;
 * As an example, the following code fragment reads characters from standard input,
 * one character at a time, and prints it to standard output.
 * &amp;lt;pre&amp;gt;
 * while (!StdIn.hasNextChar()) {
 * char c = StdIn.readChar();
 * StdOut.print(c);
 * }
 * &amp;lt;/pre&amp;gt;
 * &lt;p&gt;
 * &amp;lt;b&amp;gt;Reading lines from standard input, one at a time.&amp;lt;/b&amp;gt;
 * You can use the following two methods to read lines from standard input:
 * &amp;lt;ul&amp;gt;
 * &amp;lt;li&amp;gt; {@link #hasNextLine()}
 * &amp;lt;li&amp;gt; {@link #readLine()}
 * &amp;lt;/ul&amp;gt;
 * &lt;p&gt;
 * The first method returns true if standard input has more input (including whitespace).
 * The second method reads and returns the remaining portion of
 * the next line of input on standard input (possibly whitespace),
 * discarding the trailing line separator.
 * &lt;p&gt;
 * A &amp;lt;em&amp;gt;line separator&amp;lt;/em&amp;gt; is defined to be one of the following strings:
 * {@code \n} (Linux), {@code \r} (old Macintosh),
 * {@code \r\n} (Windows),
 * &amp;lt;code&amp;gt;&amp;#92;u2028&amp;lt;/code&amp;gt;, &amp;lt;code&amp;gt;&amp;#92;u2029&amp;lt;/code&amp;gt;, or &amp;lt;code&amp;gt;&amp;#92;u0085&amp;lt;/code&amp;gt;.
 * &lt;p&gt;
 * As an example, the following code fragment reads text from standard input,
 * one line at a time, and prints it to standard output.
 * &amp;lt;pre&amp;gt;
 * while (!StdIn.hasNextLine()) {
 * String line = StdIn.readLine();
 * StdOut.println(line);
 * }
 * &amp;lt;/pre&amp;gt;
 * &lt;p&gt;
 * &amp;lt;b&amp;gt;Reading a sequence of values of the same type from standard input.&amp;lt;/b&amp;gt;
 * You can use the following methods to read a sequence numbers, strings,
 * or booleans (all of the same type) from standard input:
 * &amp;lt;ul&amp;gt;
 * &amp;lt;li&amp;gt; {@link #readAllDoubles()}
 * &amp;lt;li&amp;gt; {@link #readAllInts()}
 * &amp;lt;li&amp;gt; {@link #readAllStrings()}
 * &amp;lt;li&amp;gt; {@link #readAllLines()}
 * &amp;lt;li&amp;gt; {@link #readAll()}
 * &amp;lt;/ul&amp;gt;
 * &lt;p&gt;
 * The first three methods read of all of remaining token on standard input
 * and dconverts the tokens to values of
 * the specified type, as in the corresponding
 * {@code readDouble}, {@code readInt}, and {@code readString()} methods.
 * The {@code readAllLines()} method reads all remaining lines on standard
 * input and returns them as an array of strings.
 * The {@code readAll()} method reads all remaining input on standard
 * input and returns it as a string.
 * &lt;p&gt;
 * As an example, the following code fragment reads all of the remaining
 * tokens from standard input and returns them as an array of strings.
 * &amp;lt;pre&amp;gt;
 * String[] words = StdIn.readAllStrings();
 * &amp;lt;/pre&amp;gt;
 * &lt;p&gt;
 * &amp;lt;b&amp;gt;Differences with Scanner.&amp;lt;/b&amp;gt;
 * {@code StdIn} and {@link Scanner} are both designed to parse
 * tokens and convert them to primitive types and strings.
 * Some of the main differences are summarized below:
 * &amp;lt;ul&amp;gt;
 * &amp;lt;li&amp;gt; {@code StdIn} is a set of static methods and reads
 * reads input from only standard input. It is suitable for use before
 * a programmer knows about objects.
 * &lt;p&gt;
 * input from files, URLs,
 * and sockets.
 * &amp;lt;li&amp;gt; {@code StdIn} uses whitespace as the delimiter between tokens.
 * &amp;lt;li&amp;gt; {@code StdIn} coerces the character-set encoding to UTF-8,
 * which is a standard character encoding for Unicode.
 * &amp;lt;li&amp;gt; {@code StdIn} coerces the locale to {@link Locale#US},
 * for consistency with {@link StdOut}, {@link Double#parseDouble(String)},
 * and floating-point literals.
 * &amp;lt;li&amp;gt; {@code StdIn} has convenient methods for reading a single
 * character; reading in sequences of integers, doubles, or strings;
 * and reading in all of the remaining input.
 * &amp;lt;/ul&amp;gt;
 * &lt;p&gt;
 * Historical note: {@code StdIn} preceded {@code Scanner}; when
 * {@code Scanner} was introduced, this class was reimplemented to use {@code Scanner}.
 * &lt;p&gt;
 * &amp;lt;b&amp;gt;Using standard input.&amp;lt;/b&amp;gt;
 * Standard input is fundamental operating system abstraction, on Mac OS X,
 * Windows, and Linux.
 * The methods in {@code StdIn} are &amp;lt;em&amp;gt;blocking&amp;lt;/em&amp;gt;, which means that they
 * will wait until you enter input on standard input.
 * If your program has a loop that repeats until standard input is empty,
 * you must signal that the input is finished.
 * To do so, depending on your operating system and IDE,
 * use either {@code &amp;lt;Ctrl-d&amp;gt;} or {@code &amp;lt;Ctrl-z&amp;gt;}, on its own line.
 * If you are redirecting standard input from a file, you will not need
 * to do anything to signal that the input is finished.
 * &lt;p&gt;
 * &amp;lt;b&amp;gt;Known bugs.&amp;lt;/b&amp;gt;
 * Java's UTF-8 encoding does not recognize the optional
 * &amp;lt;a href = &quot;http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4508058&quot;&amp;gt;byte-order mask&amp;lt;/a&amp;gt;.
 * If the input begins with the optional byte-order mask, &amp;lt;tt&amp;gt;StdIn&amp;lt;/tt&amp;gt;
 * will have an extra character &amp;lt;code&amp;gt;&amp;#92;uFEFF&amp;lt;/code&amp;gt; at the beginning.
 * &lt;p&gt;
 * &amp;lt;b&amp;gt;Reference.&amp;lt;/b&amp;gt;
 * For additional documentation,
 * see &amp;lt;a href=&quot;http://introcs.cs.princeton.edu/15inout&quot;&amp;gt;Section 1.5&amp;lt;/a&amp;gt; of
 * &amp;lt;em&amp;gt;Introduction to Programming in Java: An Interdisciplinary Approach&amp;lt;/em&amp;gt;
 * by Robert Sedgewick and Kevin Wayne.
 *
 * @author David Pritchard
 * @author Robert Sedgewick
 * @author Kevin Wayne
 */
<span class="nc bnc" id="L200" title="All 2 branches missed.">public final class StdIn</span>
{
<span class="nc" id="L202">private static final Logger LOG = LoggerFactory.getInstance().makeNewLoggerInstance(&quot;StdDInAssister&quot;);</span>
    /**
     * * begin: section (1 of 2) of code duplicated from In to StdIn.
     */
    // assume Unicode UTF-8 encoding
    private static final String CHARSET_NAME = &quot;UTF-8&quot;;

    // assume language = English, country = US for consistency with System.out.
<span class="nc" id="L210">    private static final Locale LOCALE = Locale.US;</span>

    // the default token separator; we maintain the invariant that this value
    // is held by the scanner's delimiter between calls
<span class="nc" id="L214">    private static final Pattern WHITESPACE_PATTERN = Pattern.compile(&quot;\\p{javaWhitespace}+&quot;);</span>

    // makes whitespace significant
<span class="nc" id="L217">    private static final Pattern EMPTY_PATTERN = Pattern.compile(&quot;&quot;);</span>

    // used to read the entire input
<span class="nc" id="L220">    private static final Pattern EVERYTHING_PATTERN = Pattern.compile(&quot;\\A&quot;);</span>

    /**
     * * end: section (1 of 2) of code duplicated from In to StdIn.
     */
    private static Scanner scanner;

    // it doesn't make sense to instantiate this class
    private StdIn()
<span class="nc" id="L229">    {</span>
<span class="nc" id="L230">    }</span>

    //// begin: section (2 of 2) of code duplicated from In to StdIn,
    //// with all methods changed from &quot;public&quot; to &quot;public static&quot;
    /**
     * Returns true if standard input is empty (except possibly for whitespace).
     * Use this method to know whether the next call to {@link #readString()},
     * {@link #readDouble()}, etc will succeed.
     *
     * @return &lt;tt&gt;true&lt;/tt&gt; if standard input is empty (except possibly
     *         for whitespace); &lt;tt&gt;false&lt;/tt&gt; otherwise
     */
    public static boolean isEmpty()
    {
<span class="nc bnc" id="L244" title="All 2 branches missed.">        return !scanner.hasNext();</span>
    }

    /**
     * Returns true if standard input has a next line.
     * Use this method to know whether the
     * next call to {@link #readLine()} will succeed.
     * This method is functionally equivalent to {@link #hasNextChar()}.
     *
     * @return &lt;tt&gt;true&lt;/tt&gt; if standard input is empty;
     * &lt;tt&gt;false&lt;/tt&gt; otherwise
     */
    public static boolean hasNextLine()
    {
<span class="nc" id="L258">        return scanner.hasNextLine();</span>
    }

    /**
     * Returns true if standard input has more inputy (including whitespace).
     * Use this method to know whether the next call to {@link #readChar()} will succeed.
     * This method is functionally equivalent to {@link #hasNextLine()}.
     *
     * @return &lt;tt&gt;true&lt;/tt&gt; if standard input has more input (including whitespace);
     * &lt;tt&gt;false&lt;/tt&gt; otherwise
     */
    public static boolean hasNextChar()
    {
<span class="nc" id="L271">        scanner.useDelimiter(EMPTY_PATTERN);</span>
<span class="nc" id="L272">        boolean result = scanner.hasNext();</span>
<span class="nc" id="L273">        scanner.useDelimiter(WHITESPACE_PATTERN);</span>
<span class="nc" id="L274">        return result;</span>
    }

    /**
     * Reads and returns the next line, excluding the line separator if present.
     *
     * @return the next line, excluding the line separator if present;
     * &lt;tt&gt;null&lt;/tt&gt; if no such line
     */
    public static String readLine()
    {
        String line;
        try
        {
<span class="nc" id="L288">            line = scanner.nextLine();</span>
        }
<span class="nc" id="L290">        catch (NoSuchElementException e)</span>
        {
<span class="nc" id="L292">            LOG.trace(&quot;Reached end of line&quot;,e);</span>
<span class="nc" id="L293">            line = null;</span>
<span class="nc" id="L294">        }</span>
<span class="nc" id="L295">        return line;</span>
    }

    /**
     * Reads and returns the next character.
     *
     * @return the next character
     *
     * @throws NoSuchElementException if standard input is empty
     */
    public static char readChar()
    {
<span class="nc" id="L307">        scanner.useDelimiter(EMPTY_PATTERN);</span>
<span class="nc" id="L308">        String ch = scanner.next();</span>
<span class="nc bnc" id="L309" title="All 4 branches missed.">        assert ch.length() == 1 : &quot;Internal (Std)In.readChar() error!&quot;</span>
                + &quot; Please contact the authors.&quot;;
<span class="nc" id="L311">        scanner.useDelimiter(WHITESPACE_PATTERN);</span>
<span class="nc" id="L312">        return ch.charAt(0);</span>
    }

    /**
     * Reads and returns the remainder of the input, as a string.
     *
     * @return the remainder of the input, as a string
     *
     * @throws NoSuchElementException if standard input is empty
     */
    public static String readAll()
    {
<span class="nc bnc" id="L324" title="All 2 branches missed.">        if (!scanner.hasNextLine())</span>
        {
<span class="nc" id="L326">            return &quot;&quot;;</span>
        }

<span class="nc" id="L329">        String result = scanner.useDelimiter(EVERYTHING_PATTERN).next();</span>
        // not that important to reset delimeter, since now scanner is empty
<span class="nc" id="L331">        scanner.useDelimiter(WHITESPACE_PATTERN); // but let's do it anyway</span>
<span class="nc" id="L332">        return result;</span>
    }

    /**
     * Reads the next token and returns the &lt;tt&gt;String&lt;/tt&gt;.
     *
     * @return the next &lt;tt&gt;String&lt;/tt&gt;
     *
     * @throws NoSuchElementException if standard input is empty
     */
    public static String readString()
    {
<span class="nc" id="L344">        return scanner.next();</span>
    }

    /**
     * Reads the next token from standard input, parses it as an integer, and returns the integer.
     *
     * @return the next integer on standard input
     *
     * @throws NoSuchElementException if standard input is empty
     * @throws InputMismatchException if the next token cannot be parsed as an &lt;tt&gt;int&lt;/tt&gt;
     */
    public static int readInt()
    {
<span class="nc" id="L357">        return scanner.nextInt();</span>
    }

    /**
     * Reads the next token from standard input, parses it as a double, and returns the double.
     *
     * @return the next double on standard input
     *
     * @throws NoSuchElementException if standard input is empty
     * @throws InputMismatchException if the next token cannot be parsed as a &lt;tt&gt;double&lt;/tt&gt;
     */
    public static double readDouble()
    {
<span class="nc" id="L370">        return scanner.nextDouble();</span>
    }

    /**
     * Reads the next token from standard input, parses it as a float, and returns the float.
     *
     * @return the next float on standard input
     *
     * @throws NoSuchElementException if standard input is empty
     * @throws InputMismatchException if the next token cannot be parsed as a &lt;tt&gt;float&lt;/tt&gt;
     */
    public static float readFloat()
    {
<span class="nc" id="L383">        return scanner.nextFloat();</span>
    }

    /**
     * Reads the next token from standard input, parses it as a long integer, and returns the long integer.
     *
     * @return the next long integer on standard input
     *
     * @throws NoSuchElementException if standard input is empty
     * @throws InputMismatchException if the next token cannot be parsed as a &lt;tt&gt;long&lt;/tt&gt;
     */
    public static long readLong()
    {
<span class="nc" id="L396">        return scanner.nextLong();</span>
    }

    /**
     * Reads the next token from standard input, parses it as a short integer, and returns the short integer.
     *
     * @return the next short integer on standard input
     *
     * @throws NoSuchElementException if standard input is empty
     * @throws InputMismatchException if the next token cannot be parsed as a &lt;tt&gt;short&lt;/tt&gt;
     */
    public static short readShort()
    {
<span class="nc" id="L409">        return scanner.nextShort();</span>
    }

    /**
     * Reads the next token from standard input, parses it as a byte, and returns the byte.
     *
     * @return the next byte on standard input
     *
     * @throws NoSuchElementException if standard input is empty
     * @throws InputMismatchException if the next token cannot be parsed as a &lt;tt&gt;byte&lt;/tt&gt;
     */
    public static byte readByte()
    {
<span class="nc" id="L422">        return scanner.nextByte();</span>
    }

    /**
     * Reads the next token from standard input, parses it as a boolean,
     * and returns the boolean.
     *
     * @return the next boolean on standard input
     *
     * @throws NoSuchElementException if standard input is empty
     * @throws InputMismatchException if the next token cannot be parsed as a &lt;tt&gt;boolean&lt;/tt&gt;:
     * &lt;tt&gt;true&lt;/tt&gt; or &lt;tt&gt;1&lt;/tt&gt; for true, and &lt;tt&gt;false&lt;/tt&gt; or &lt;tt&gt;0&lt;/tt&gt; for false,
     * ignoring case
     */
    public static boolean readBoolean()
    {
<span class="nc" id="L438">        String s = readString();</span>
<span class="nc bnc" id="L439" title="All 2 branches missed.">        if (s.equalsIgnoreCase(&quot;true&quot;))</span>
        {
<span class="nc" id="L441">            return true;</span>
        }
<span class="nc bnc" id="L443" title="All 2 branches missed.">        if (s.equalsIgnoreCase(&quot;false&quot;))</span>
        {
<span class="nc" id="L445">            return false;</span>
        }
<span class="nc bnc" id="L447" title="All 2 branches missed.">        if (s.equals(&quot;1&quot;))</span>
        {
<span class="nc" id="L449">            return true;</span>
        }
<span class="nc bnc" id="L451" title="All 2 branches missed.">        if (s.equals(&quot;0&quot;))</span>
        {
<span class="nc" id="L453">            return false;</span>
        }
<span class="nc" id="L455">        throw new InputMismatchException();</span>
    }

    /**
     * Reads all remaining tokens from standard input and returns them as an array of strings.
     *
     * @return all remaining tokens on standard input, as an array of strings
     */
    public static String[] readAllStrings()
    {
        // we could use readAll.trim().split(), but that's not consistent
        // because trim() uses characters 0x00..0x20 as whitespace
<span class="nc" id="L467">        String[] tokens = WHITESPACE_PATTERN.split(readAll());</span>
<span class="nc bnc" id="L468" title="All 4 branches missed.">        if (tokens.length == 0 || tokens[0].length() &gt; 0)</span>
        {
<span class="nc" id="L470">            return tokens;</span>
        }

        // don't include first token if it is leading whitespace
<span class="nc" id="L474">        String[] decapitokens = new String[tokens.length - 1];</span>
<span class="nc bnc" id="L475" title="All 2 branches missed.">        for (int i = 0; i &lt; tokens.length - 1; i++)</span>
        {
<span class="nc" id="L477">            decapitokens[i] = tokens[i + 1];</span>
        }
<span class="nc" id="L479">        return decapitokens;</span>
    }

    /**
     * Reads all remaining lines from standard input and returns them as an array of strings.
     *
     * @return all remaining lines on standard input, as an array of strings
     */
    public static String[] readAllLines()
    {
<span class="nc" id="L489">        ArrayList&lt;String&gt; lines = new ArrayList&lt;String&gt;();</span>
<span class="nc bnc" id="L490" title="All 2 branches missed.">        while (hasNextLine())</span>
        {
<span class="nc" id="L492">            lines.add(readLine());</span>
        }
<span class="nc" id="L494">        return lines.toArray(new String[0]);</span>
    }

    /**
     * Reads all remaining tokens from standard input, parses them as integers, and returns
     * them as an array of integers.
     *
     * @return all remaining integers on standard input, as an array
     *
     * @throws InputMismatchException if any token cannot be parsed as an &lt;tt&gt;int&lt;/tt&gt;
     */
    public static int[] readAllInts()
    {
<span class="nc" id="L507">        String[] fields = readAllStrings();</span>
<span class="nc" id="L508">        int[] vals = new int[fields.length];</span>
<span class="nc bnc" id="L509" title="All 2 branches missed.">        for (int i = 0; i &lt; fields.length; i++)</span>
        {
<span class="nc" id="L511">            vals[i] = Integer.parseInt(fields[i]);</span>
        }
<span class="nc" id="L513">        return vals;</span>
    }

    /**
     * Reads all remaining tokens from standard input, parses them as doubles, and returns
     * them as an array of doubles.
     *
     * @return all remaining doubles on standard input, as an array
     *
     * @throws InputMismatchException if any token cannot be parsed as a &lt;tt&gt;double&lt;/tt&gt;
     */
    public static double[] readAllDoubles()
    {
<span class="nc" id="L526">        String[] fields = readAllStrings();</span>
<span class="nc" id="L527">        double[] vals = new double[fields.length];</span>
<span class="nc bnc" id="L528" title="All 2 branches missed.">        for (int i = 0; i &lt; fields.length; i++)</span>
        {
<span class="nc" id="L530">            vals[i] = Double.parseDouble(fields[i]);</span>
        }
<span class="nc" id="L532">        return vals;</span>
    }

    //// end: section (2 of 2) of code duplicated from In to StdIn
    // do this once when StdIn is initialized
    static
    {
<span class="nc" id="L539">        resync();</span>
<span class="nc" id="L540">    }</span>

    /**
     * If StdIn changes, use this to reinitialize the scanner.
     */
    private static void resync()
    {
<span class="nc" id="L547">        setScanner(new Scanner(new java.io.BufferedInputStream(System.in), CHARSET_NAME));</span>
<span class="nc" id="L548">    }</span>

    private static void setScanner(Scanner scanner)
    {
<span class="nc" id="L552">        StdIn.scanner = scanner;</span>
<span class="nc" id="L553">        StdIn.scanner.useLocale(LOCALE);</span>
<span class="nc" id="L554">    }</span>

    /**
     * Reads all remaining tokens, parses them as integers, and returns
     * them as an array of integers.
     *
     * @return all remaining integers, as an array
     *
     * @throws InputMismatchException if any token cannot be parsed as an &lt;tt&gt;int&lt;/tt&gt;
     * @deprecated Replaced by {@link #readAllInts()}.
     */
    public static int[] readInts()
    {
<span class="nc" id="L567">        return readAllInts();</span>
    }

    /**
     * Reads all remaining tokens, parses them as doubles, and returns
     * them as an array of doubles.
     *
     * @return all remaining doubles, as an array
     *
     * @throws InputMismatchException if any token cannot be parsed as a &lt;tt&gt;double&lt;/tt&gt;
     * @deprecated Replaced by {@link #readAllDoubles()}.
     */
    public static double[] readDoubles()
    {
<span class="nc" id="L581">        return readAllDoubles();</span>
    }

    /**
     * Reads all remaining tokens and returns them as an array of strings.
     *
     * @return all remaining tokens, as an array of strings
     *
     * @deprecated Replaced by {@link #readAllStrings()}.
     */
    public static String[] readStrings()
    {
<span class="nc" id="L593">        return readAllStrings();</span>
    }

    /**
     * Interactive test of basic functionality.
     */
    public static void main(String[] args)
    {

<span class="nc" id="L602">        StdOut.print(&quot;Type a string: &quot;);</span>
<span class="nc" id="L603">        String s = StdIn.readString();</span>
<span class="nc" id="L604">        StdOut.println(&quot;Your string was: &quot; + s);</span>
<span class="nc" id="L605">        StdOut.println();</span>

<span class="nc" id="L607">        StdOut.print(&quot;Type an int: &quot;);</span>
<span class="nc" id="L608">        int a = StdIn.readInt();</span>
<span class="nc" id="L609">        StdOut.println(&quot;Your int was: &quot; + a);</span>
<span class="nc" id="L610">        StdOut.println();</span>

<span class="nc" id="L612">        StdOut.print(&quot;Type a boolean: &quot;);</span>
<span class="nc" id="L613">        boolean b = StdIn.readBoolean();</span>
<span class="nc" id="L614">        StdOut.println(&quot;Your boolean was: &quot; + b);</span>
<span class="nc" id="L615">        StdOut.println();</span>

<span class="nc" id="L617">        StdOut.print(&quot;Type a double: &quot;);</span>
<span class="nc" id="L618">        double c = StdIn.readDouble();</span>
<span class="nc" id="L619">        StdOut.println(&quot;Your double was: &quot; + c);</span>
<span class="nc" id="L620">        StdOut.println();</span>

<span class="nc" id="L622">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>